import { Inject, Injectable } from '@nestjs/common';
import { <<Model pascal>>, Prisma<<if Fields internal and ownership and not primary>>, User<<endif>>  } from '@prisma/client';

<<if Fields internal and entity>>
import { Merge } from 'ts-essentials';
<<endif>>

<<if Fields object>>
import { JsonObject } from '../../../../../../../../common/src';
<<endif>>

import {
  <<if Fields manyMany>>
  formatEntityIds,
  <<endif>>
  formatSort,
  formatFilterType,
} from '@tractr/nestjs-core';

import {
  <<Model pascal>>Service,
  <<Model constant>>_SERVICE,
} from '../../../../nestjs-models-common';
import { AppAbility } from '@tractr/generated-casl';
import { accessibleBy } from '@casl/prisma';
import { isEmpty } from 'lodash';

import {
  <<Model pascal>>CountQueryDto,
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>DeleteParamsDto,
  <<Model pascal>>FindManyQueryDto,
  <<Model pascal>>FindUniqueParamsDto,
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpdateParamsDto,
  <<Model pascal>>UpsertBodyDto,
  <<Model pascal>>UpsertParamsDto,
} from '../../../../rest-dtos';

import { <<Model constant>>_SELECT } from '../constants';
import { <<Model pascal>>WithRelationIds } from '../types';
import { <<Model pascal>> as <<Model pascal>>Dto } from '../../../../models';

@Injectable()
export class <<Model pascal>>RestDtoService {

  constructor(
    @Inject(<<Model constant>>_SERVICE)
    protected <<Model camel>>Service: <<Model pascal>>Service,
  ) {}


<<if Fields ownership and not primary>>
  /**
   * Format dtos to create a <<Model pascal>>
   *
   * @param bodyDto - A valid body dto to create a <<Model pascal>>
   * @returns prisma parameters to create a <<Model pascal>>
   */
  public transformCreateDtoTo<<Model pascal>>(
    bodyDto: <<Model pascal>>CreateBodyDto,
    <<if Fields ownership and internal and not primary>>user: User<<endif>>
  ): <<<if (root.properties.hasPrimary) {>>>Omit<<<Model pascal>>, '<<=root.fields.primary.names.camel>>'> <<<} else { >>><<Model pascal>> <<<}>>> {
    const {
<<for Fields not internal and not manyOne field>>
      <<field camel>>,
<<endfor>>
    } = bodyDto;

    return {
<<if Fields internal and not primary and (not entity or nullable)>>
      ...this.<<Model camel>>Service.getDefaultInternals(),
<<endif>>
<<for Fields  ownership and internal and not primary field>>
      <<field camel>>Id:user.id,
<<endfor>>
<<for Fields entity and not internal and not manyOne field>>
  <<if field oneOne or oneMany>>
    <<<if (field.names.camel === 'id') {>>>
      id<<<} else {>>>
    <<field camel>>Id<<<}>>>: <<field camel>><<if field nullable>> ?? null<<endif>>,
  <<endif>>
<<endfor>>
<<for Fields not entity and not internal field>>
  <<if field nullable>>
      <<field camel>>: <<field camel>> ?? null,
  <<else>>
      <<field camel>>,
  <<endif>>
<<endfor>>
    }
  }

  /**
   * Format dtos to upsert a <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to upsert a <<Model pascal>>
   * @param bodyDto - A valid body dto to upsert a <<Model pascal>>
   * @returns prisma parameters to create a <<Model pascal>>
   */
  public transformUpsertDtoTo<<Model pascal>>(
    paramsDto: <<Model pascal>>UpsertParamsDto,
    bodyDto: <<Model pascal>>UpsertBodyDto,
    <<if Fields ownership and internal and not primary>>user: User<<endif>>
  ): <<<if (root.properties.hasPrimary) {>>>Omit<<<Model pascal>>, '<<=root.fields.primary.names.camel>>'> & Partial<Pick<<<Model pascal>>, '<<=root.fields.primary.names.camel>>'>> <<<} else { >>><<Model pascal>> <<<}>>> {
    const {
    <<for Fields primary primaryField>>
      <<primaryField camel>>,
    <<endfor>>
    } = paramsDto;
    const {
<<for Fields not internal and not manyOne field>>
      <<field camel>>,
<<endfor>>
    } = bodyDto;

    return {
    <<for Fields primary primaryField>>
      <<primaryField camel>>,
    <<endfor>>
<<if Fields internal and not primary and (not entity or nullable)>>
      ...this.<<Model camel>>Service.getDefaultInternals(),
<<endif>>
<<for Fields  ownership and internal and not primary field>>
      <<field camel>>Id:user.id,
<<endfor>>
<<for Fields entity and not internal and not manyOne field>>
  <<if field oneOne or oneMany>>
    <<<if (field.names.camel === 'id') {>>>
      id<<<} else {>>>
    <<field camel>>Id<<<}>>>: <<field camel>><<if field nullable>> ?? null<<endif>>,
  <<endif>>
<<endfor>>
<<for Fields not entity and not internal field>>
  <<if field nullable>>
      <<field camel>>: <<field camel>> ?? null,
  <<else>>
      <<field camel>>,
  <<endif>>
<<endfor>>
    }
  }
<<endif>>

  /**
   * Format dtos to create a <<Model pascal>>
   *
   * @param bodyDto - A valid body dto to create a <<Model pascal>>
   * @returns prisma parameters to create a <<Model pascal>>
   */
  public formatCreateDto(
    bodyDto: <<Model pascal>>CreateBodyDto,
    <<if Fields ownership and internal and not primary>>user: User,<<endif>>
  ):
    <<if Fields internal and entity>>
    Merge<
      Prisma.<<Model pascal>>CreateArgs,
      {
        data: Omit<Prisma.<<Model pascal>>CreateInput,
        <<for Fields internal and entity and not manyOne field>>
          | '<<field camel>>'
        <<endfor>>
        >;
      }
    >
    <<else>>
    Prisma.<<Model pascal>>CreateArgs
    <<endif>>
  {
    const {
<<for Fields entity and not internal and not manyOne field>>
      <<field camel>>,
<<endfor>>
    ...values
    } = bodyDto;

    const data: Prisma.<<Model pascal>>CreateInput = {
<<if Fields internal and not primary and (not entity or nullable)>>
      ...this.<<Model camel>>Service.getDefaultInternals(),
<<endif>>
<<if Fields ownership and internal and not primary>>
      ...this.<<Model camel>>Service.getDefaultOwnerships(user),
<<endif>>
      ...values,
<<for Fields entity and not internal and not manyOne field>>
  <<if field oneOne or oneMany>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
    <<else>>
      <<field camel>>: { connect: { id: <<field camel>> } },
    <<endif>>
  <<else>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { connect: formatEntityIds(<<field camel>>) } : undefined,
    <<else>>
      <<field camel>>: { connect: formatEntityIds(<<field camel>>) },
    <<endif>>
  <<endif>>
<<endfor>>
    }

    return {
      data
    };
  }

  /**
   * Format dtos to count <<Model pascal>> entities
   *
   * @param queryDto - A valid query dto to filter <<Model pascal>> entities
   * @param abilities - User's abilities
   * @returns prisma parameters to count <<Model pascal>> entities
   */
  public formatCountDtoToQuery(
    queryDto: <<Model pascal>>CountQueryDto,
    abilities: AppAbility,
  ): Prisma.<<Model pascal>>CountArgs {
    const filters = { ...queryDto };

    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ),
    };
  }

  /**
   * Format dtos to find a unique <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
   * @param abilities - User's abilities
   * @returns prisma parameters to find a unique <<Model pascal>>
   */
  public formatFindUniqueDtoToQuery(
    paramsDto: <<Model pascal>>FindUniqueParamsDto,
    abilities: AppAbility,
  ): Prisma.<<Model pascal>>FindUniqueArgs {
    const filters = {...paramsDto};
    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ) as Prisma.<<Model pascal>>WhereUniqueInput,
      // Set select clause with ownership checks
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
    };
  }

  /**
   * Format dtos to find many <<Model pascal>> entities
   *
   * @param queryDto - A valid query dto to filter <<Model pascal>> entities
   * @param abilities - User's abilities
   * @returns prisma parameters to find many <<Model pascal>> entities
   */
  public formatFindManyDtoToQuery(
    queryDto: <<Model pascal>>FindManyQueryDto,
    abilities: AppAbility,
  ) {
    const { sort, order, take, skip, ...filters } = queryDto;

    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ),
      // Set select clause with ownership checks
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
      // Set sort clause
      orderBy: sort ? formatSort(sort, order) : undefined,
      // Set pagination clauses
      skip: skip ?  Number(skip) : undefined,
      take: take ? Number(take) : undefined,
    };
  }

  /**
   * Format dtos to update a <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
   * @param bodyDto - A valid body dto to update a <<Model pascal>>
   * @param abilities - User's abilities
   * @returns prisma parameters to update a <<Model pascal>>
   */
  public formatUpdateDtos(
    paramsDto: <<Model pascal>>UpdateParamsDto,
    bodyDto: <<Model pascal>>UpdateBodyDto
  ): Prisma.<<Model pascal>>UpdateArgs {
    const {
    <<for Fields not internal and entity and not manyOne field>>
      <<field camel>>,
    <<endfor>>
      ...values
    } = bodyDto;

    const data: Prisma.<<Model pascal>>UpdateInput = {
<<for Fields not internal and entity and not manyOne field>>
  <<if field oneOne or oneMany>>
      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
  <<else>>
      <<field camel>>: <<field camel>> ? { set: formatEntityIds(<<field camel>>) } : undefined,
  <<endif>>
<<endfor>>
      ...values
    }
    return { data, where: { ...paramsDto } };
  }

  /**
   * Format dtos to create or update a <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
   * @param bodyDto - A valid body dto to create or update a <<Model pascal>>
   * @returns prisma parameters to create or update a <<Model pascal>>
   */
  public formatUpsertDtos(
    paramsDto: <<Model pascal>>UpsertParamsDto,
    bodyDto: <<Model pascal>>UpsertBodyDto,
    <<if Fields internal and ownership and not primary>>user: User<<endif>>
  ):
    <<if Fields internal and entity>>
    Merge<
      Prisma.<<Model pascal>>UpsertArgs,
      {
        create: Omit<Prisma.<<Model pascal>>CreateInput,
        <<for Fields internal and entity and not manyOne field>>
          | '<<field camel>>'
        <<endfor>>
        >;
      }
    >
    <<else>>
    Prisma.<<Model pascal>>UpsertArgs
    <<endif>>
  {
    const {
    <<for Fields entity and not internal and not manyOne field>>
      <<field camel>>,
    <<endfor>>
    ...values
    } = bodyDto;

    const create: Prisma.<<Model pascal>>CreateInput = {
    <<if Fields internal and not primary and (not entity or nullable)>>
      ...this.<<Model camel>>Service.getDefaultInternals(),
    <<endif>>
    <<if Fields internal and ownership and not primary>>
      ...this.<<Model camel>>Service.getDefaultOwnerships(user),
    <<endif>>
      ...values,
<<for Fields entity and not internal and not manyOne field>>
  <<if field oneOne or oneMany>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
    <<else>>
      <<field camel>>: { connect: { id: <<field camel>> } },
    <<endif>>
  <<else>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { connect: formatEntityIds(<<field camel>>) } : undefined,
    <<else>>
      <<field camel>>: { connect: formatEntityIds(<<field camel>>) },
    <<endif>>
  <<endif>>
<<endfor>>
    };

    const update: Prisma.<<Model pascal>>UpdateInput = {
      ...values,
<<for Fields not internal and entity and not manyOne field>>
  <<if field oneOne or oneMany>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
    <<else>>
      <<field camel>>: { connect: { id: <<field camel>> } },
    <<endif>>
  <<elseif field manyMany>>
    <<if field nullable>>
      <<field camel>>: <<field camel>> ? { set: formatEntityIds(<<field camel>>) } : undefined,
    <<else>>
      <<field camel>>: { set: formatEntityIds(<<field camel>>) },
    <<endif>>
  <<else>>
      <<field camel>>,
  <<endif>>
<<endfor>>
    };
    return {
      create,
      update,
      where: { ...paramsDto }
    };
  }

  /**
   * Format dtos to delete a unique <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to select a unique <<Model pascal>> to delete
   * @returns prisma parameters to delete a unique <<Model pascal>>
   */
  public formatDeleteDto(
    paramsDto: <<Model pascal>>DeleteParamsDto
  ): Prisma.<<Model pascal>>DeleteArgs {
    return { where: { ...paramsDto } };
  }

  public getWhereClauseWithOwnershipConstraints(
    filters: <<Model pascal>>CountQueryDto,
    abilities: AppAbility
  ): Prisma.<<Model pascal>>WhereInput {

    // Init where clause
    const filterConstraints: Prisma.<<Model pascal>>WhereInput = {
    <<<getSearchableFields(root).forEach((field) => {>>>
      <<if field oneOne>>
        <<field camel>>: filters.<<field camel>> ?  { id: filters.<<field camel>> } : undefined,
      <<elseif field oneMany>>
        <<field camel>>: filters.<<field camel>> ?  { id: { in: formatFilterType(filters.<<field camel>>, 'string', true).equals } } : undefined,
      <<elseif field manyMany>>
        <<field camel>>: filters.<<field camel>> ? { some: { id: { in: formatFilterType(filters.<<field camel>>, 'string', true).equals } } } : undefined,
      <<else>>
        <<field camel>>: filters.<<field camel>> ? formatFilterType(filters.<<field camel>>, <<if field datetime>>'datetime'<<elseif field number>>'number'<<elseif field string>>'string'<<elseif field boolean>>'boolean'<<elseif field enum>>'enum'<<else>>'json'<<endif>>, <<if field multiple>>true<<else>>false<<endif>>)  : undefined,
      <<endif>>
    <<<})>>>
    };

    const ownershipConstraints = accessibleBy(abilities).<<Model pascal>>;

    const constraints = [filterConstraints, ownershipConstraints].filter(constraint => !isEmpty(constraint));

    if (constraints.length === 0) return {};
    if (constraints.length === 1) return constraints[0];
    return {
      AND: constraints
    }
  }

  public getSelectClauseWithOwnershipConstraints(abilities: AppAbility) {
    // Get default select clause
    const select = { ...<<Model constant>>_SELECT };

    if (!abilities) return select;

    // Add ownership constraints
    return {
      ...select,
      <<for Fields manyMany field>>
        <<field camel>>: {
          ...select.<<field camel>>,
          where: !isEmpty(accessibleBy(abilities).<<field.model pascal>>) ?
            accessibleBy(abilities).<<field.model pascal>>
            : undefined
        },
      <<endfor>>
      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
          <<-field backRelation camel>>: {
            ...select.<<-field backRelation camel>>,
            where: !isEmpty(accessibleBy(abilities).<<ref pascal>>) ?
              accessibleBy(abilities).<<ref pascal>>
              : undefined
          },
        <<endfor>>
      <<endfor>>
    }
  }

  public formatEntityWithRelationIdsToDto({
      <<for Fields manyMany field>>
        <<field camel>>,
      <<endfor>>

      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
          <<-field backRelation camel>>,
        <<endfor>>
      <<endfor>>

    ...entity
  }: <<Model pascal>>WithRelationIds):<<Model pascal>>Dto {
    return {
      ...entity,

      <<for Fields object field>>
        <<field camel>>: entity.<<field camel>> as JsonObject<<if field multiple>>[]<<endif>>,
      <<endfor>>

      <<for Fields manyMany field>>
        <<field camel>>Ids: <<field camel>>.map(({id}) => id),
      <<endfor>>

      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>

          <<if field oneOne>>
            <<-field backRelation camel>>Id: <<-field backRelation camel>>?.id ?? null,
          <<endif>>

          <<if field oneMany or manyMany>>
            <<-field backRelation camel>>Ids: <<-field backRelation camel>>.map(({id}) => id),
          <<endif>>
        <<endfor>>
      <<endfor>>
    };
  }
}
<<<
function getDefaultForType(f) {
  let out = ""
  if (f.type === "boolean") return "equals";
  else if (f.type === "string") return "equals";
  else if (f.type === "number") return "equals";
  else if (f.type === "datetime") return "equals";
  else if (f.type === "object") return "equals";

  return "UnknownType";
}
>>>

<<<
function getSearchableFields(model) {
  return model
    .fields.list
    .concat(...model.referencedIn)
    .filter((field) => field.searchable && !field.password && !field.hidden);
}
>>>

