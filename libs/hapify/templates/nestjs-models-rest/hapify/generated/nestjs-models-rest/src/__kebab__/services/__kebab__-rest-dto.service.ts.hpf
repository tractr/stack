
import { Injectable } from '@nestjs/common';
import { <<Model pascal>>, Prisma<<if Fields internal and ownership and not primary>>, User<<endif>>  } from '@prisma/client';

<<if Fields internal and entity>>
import { Merge } from 'ts-essentials';
<<endif>>

<<if Fields object>>
import { JsonObject } from '../../../../../../../../common/src';
<<endif>>

import {
  <<if Fields manyMany>>
  formatEntityIds,
  <<endif>>
  formatSort,
  formatFilterType,
} from '@tractr/nestjs-core';

import { accessibleBy } from '@casl/prisma';
import { ForbiddenError, subject } from '@casl/ability';
import { Actions, AppAbility } from '../../../../casl';
import { isEmpty } from 'lodash';

import {
  <<Model pascal>>CountQueryDto,
  <<Model pascal>>DeleteParamsDto,
  <<Model pascal>>FindManyQueryDto,
  <<Model pascal>>FindUniqueParamsDto,
} from '../../../../rest-dtos';

import {
  <<Model constant>>_SELECT,
  <<Model pascal>>Dto,
  <<Model pascal>>ReadDto,
  <<Model pascal>>WriteDto,
} from '../../../../models';

@Injectable()
export class <<Model pascal>>RestDtoService {


  /**
   * Format dtos to create a <<Model pascal>>
   *
   * @param bodyDto - A valid body dto to create a <<Model pascal>>
   * @returns prisma parameters to create a <<Model pascal>>
   */
  public formatCreateDtoToQuery(
    <<Model camel>>: Omit< <<Model pascal>>Dto, 'id'>,
    abilities: AppAbility,
  ) {
    // Check authorizations
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.CREATE,
      subject(
        '<<Model pascal>>',
        <<Model camel>> as unknown as <<Model pascal>>,
      ));

    return {
      data: this.getCreateDataClause(<<Model camel>>),
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
    };
  }

  /**
   * Format dtos to count <<Model pascal>> entities
   *
   * @param queryDto - A valid query dto to filter <<Model pascal>> entities
   * @param abilities - User's abilities
   * @returns prisma parameters to count <<Model pascal>> entities
   */
  public formatCountDtoToQuery(
    queryDto: <<Model pascal>>CountQueryDto,
    abilities: AppAbility,
  ): Prisma.<<Model pascal>>CountArgs {
    const filters = { ...queryDto };

    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ),
    };
  }

  /**
   * Format dtos to find a unique <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
   * @param abilities - User's abilities
   * @returns prisma parameters to find a unique <<Model pascal>>
   */
  public formatFindUniqueDtoToQuery(
    paramsDto: <<Model pascal>>FindUniqueParamsDto,
    abilities: AppAbility,
  ) {
    const filters = {...paramsDto};
    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ) as Prisma.<<Model pascal>>WhereUniqueInput,
      // Set select clause with ownership checks
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
    };
  }

  /**
   * Format dtos to find many <<Model pascal>> entities
   *
   * @param queryDto - A valid query dto to filter <<Model pascal>> entities
   * @param abilities - User's abilities
   * @returns prisma parameters to find many <<Model pascal>> entities
   */
  public formatFindManyDtoToQuery(
    queryDto: <<Model pascal>>FindManyQueryDto,
    abilities: AppAbility,
  ) {
    const { sort, order, take, skip, ...filters } = queryDto;

    return {
      // Set where clause with filters and ownership constraints
      where: this.getWhereClauseWithOwnershipConstraints(
        filters,
        abilities,
      ),
      // Set select clause with ownership checks
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
      // Set sort clause
      orderBy: sort ? formatSort(sort, order) : undefined,
      // Set pagination clauses
      skip: skip ?  Number(skip) : undefined,
      take: take ? Number(take) : undefined,
    };
  }

  /**
   * Format dtos to update a <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
   * @param bodyDto - A valid body dto to update a <<Model pascal>>
   * @param abilities - User's abilities
   * @returns prisma parameters to update a <<Model pascal>>
   */
  public formatUpdateDtoToQuery(
    id: string,
    <<Model camel>>: Omit< <<Model pascal>>Dto, 'id'>,
    abilities: AppAbility,
  ) {
    return {
      where: { id },
      data: this.getUpdateDataClause(<<Model camel>>),
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
    };
  }

//  /**
//   * Format dtos to create or update a <<Model pascal>>
//   *
//   * @param paramsDto - A valid params dto to find a unique <<Model pascal>>
//   * @param bodyDto - A valid body dto to create or update a <<Model pascal>>
//   * @returns prisma parameters to create or update a <<Model pascal>>
//   */
//  public formatUpsertDtos(
//    paramsDto: <<Model pascal>>UpsertParamsDto,
//    bodyDto: <<Model pascal>>UpsertBodyDto,
//    abilities: AppAbility,
//    <<if Fields internal and ownership and not primary>>user: User<<endif>>
//  ):
//    <<if Fields internal and entity>>
//    Merge<
//      Prisma.<<Model pascal>>UpsertArgs,
//      {
//        create: Omit<Prisma.<<Model pascal>>CreateInput,
//        <<for Fields internal and entity and not manyOne field>>
//          | '<<field camel>>'
//        <<endfor>>
//        >;
//      }
//    >
//    <<else>>
//    Prisma.<<Model pascal>>UpsertArgs
//    <<endif>>
//  {
//    const {
//    <<for Fields entity and not internal and not manyOne field>>
//      <<field camel>>,
//    <<endfor>>
//    ...values
//    } = bodyDto;
//
//    const create: Prisma.<<Model pascal>>CreateInput = {
//    <<if Fields internal and not primary and (not entity or nullable)>>
//      ...this.<<Model camel>>Service.getDefaultInternals(),
//    <<endif>>
//    <<if Fields internal and ownership and not primary>>
//      ...this.<<Model camel>>Service.getDefaultOwnerships(user),
//    <<endif>>
//      ...values,
//<<for Fields entity and not internal and not manyOne field>>
//  <<if field oneOne or oneMany>>
//    <<if field nullable>>
//      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
//    <<else>>
//      <<field camel>>: { connect: { id: <<field camel>> } },
//    <<endif>>
//  <<else>>
//    <<if field nullable>>
//      <<field camel>>: <<field camel>> ? { connect: formatEntityIds(<<field camel>>) } : undefined,
//    <<else>>
//      <<field camel>>: { connect: formatEntityIds(<<field camel>>) },
//    <<endif>>
//  <<endif>>
//<<endfor>>
//    };
//
//    const update: Prisma.<<Model pascal>>UpdateInput = {
//      ...values,
//<<for Fields not internal and entity and not manyOne field>>
//  <<if field oneOne or oneMany>>
//    <<if field nullable>>
//      <<field camel>>: <<field camel>> ? { connect: { id: <<field camel>> } } : undefined,
//    <<else>>
//      <<field camel>>: { connect: { id: <<field camel>> } },
//    <<endif>>
//  <<elseif field manyMany>>
//    <<if field nullable>>
//      <<field camel>>: <<field camel>> ? { set: formatEntityIds(<<field camel>>) } : undefined,
//    <<else>>
//      <<field camel>>: { set: formatEntityIds(<<field camel>>) },
//    <<endif>>
//  <<else>>
//      <<field camel>>,
//  <<endif>>
//<<endfor>>
//    };
//    return {
//      create,
//      update,
//      where: { ...paramsDto },
//      select: this.getSelectClauseWithOwnershipConstraints(abilities),
//    };
//  }

  /**
   * Format dtos to delete a unique <<Model pascal>>
   *
   * @param paramsDto - A valid params dto to select a unique <<Model pascal>> to delete
   * @returns prisma parameters to delete a unique <<Model pascal>>
   */
  public formatDeleteDtoToQuery(
    paramsDto: <<Model pascal>>DeleteParamsDto,
    abilities: AppAbility,
  ) {
    return {
      where: { ...paramsDto },
      select: this.getSelectClauseWithOwnershipConstraints(abilities),
    };
  }

  /**
   * Format filters to a prisma where clause and add ownership constraints
   */
  public getWhereClauseWithOwnershipConstraints(
    filters: <<Model pascal>>CountQueryDto,
    abilities: AppAbility
  ): Prisma.<<Model pascal>>WhereInput {

    // Init where clause
    const filterConstraints: Prisma.<<Model pascal>>WhereInput = {
    <<<getSearchableFields(root).forEach((field) => {>>>
      <<if field oneOne>>
        <<field camel>>: filters.<<field camel>> ?  { id: filters.<<field camel>> } : undefined,
      <<elseif field oneMany>>
        <<field camel>>: filters.<<field camel>> ?  { id: { in: formatFilterType(filters.<<field camel>>, 'string', true).equals } } : undefined,
      <<elseif field manyMany>>
        <<field camel>>: filters.<<field camel>> ? { some: { id: { in: formatFilterType(filters.<<field camel>>, 'string', true).equals } } } : undefined,
      <<else>>
        <<field camel>>: filters.<<field camel>> ? formatFilterType(filters.<<field camel>>, <<if field datetime>>'datetime'<<elseif field number>>'number'<<elseif field string>>'string'<<elseif field boolean>>'boolean'<<elseif field enum>>'enum'<<else>>'json'<<endif>>, <<if field multiple>>true<<else>>false<<endif>>)  : undefined,
      <<endif>>
    <<<})>>>
    };

    const ownershipConstraints = accessibleBy(abilities).<<Model pascal>>;

    const constraints = [filterConstraints, ownershipConstraints].filter(constraint => !isEmpty(constraint));

    if (constraints.length === 0) return {};
    if (constraints.length === 1) return constraints[0];
    return {
      AND: constraints
    }
  }

  /**
   * Format payload to a prisma data clause and add ownership constraints
   */
  public getCreateDataClause(
   {
      <<for Fields object field>>
        <<field camel>>,
      <<endfor>>

      <<for Fields oneOne or oneMany or manyMany field>>
        <<field camel>>,
      <<endfor>>

      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
            <<-field backRelation camel>>,
        <<endfor>>
      <<endfor>>
      ...entity
    }: Omit< <<Model pascal>>Dto, 'id'>,
  ) {
    return {
      ...entity,


      <<for Fields object field>>
        <<field camel>>: <<field camel>> as Prisma.InputJsonValue<<if field multiple>>[]<<endif>>,
      <<endfor>>

      <<for Fields oneOne or oneMany or manyMany field>>
        <<if field not nullable>>
          <<field camel>>: { connect: <<field camel>> },
        <<endif>>
        <<if field nullable>>
          <<field camel>>: <<field camel>> ? { connect: <<field camel>> } : undefined,
        <<endif>>
      <<endfor>>


      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
            <<-field backRelation camel>>: <<-field backRelation camel>> ? { connect: <<-field backRelation camel>> } : undefined,
        <<endfor>>
      <<endfor>>
    };
  }

  /**
   * Format payload to a prisma data clause and add ownership constraints
   */
  public getUpdateDataClause(
   {
      <<for Fields object field>>
        <<field camel>>,
      <<endfor>>

      <<for Fields oneOne or oneMany or manyMany field>>
        <<field camel>>,
      <<endfor>>

      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
            <<-field backRelation camel>>,
        <<endfor>>
      <<endfor>>
      ...entity
    }: Omit< <<Model pascal>>Dto, 'id'>,
  ) {
    return {
      ...entity,


      <<for Fields object field>>
        <<field camel>>: <<field camel>> as Prisma.InputJsonValue<<if field multiple>>[]<<endif>>,
      <<endfor>>

      <<for Fields oneOne or oneMany or manyMany field>>
        <<if field not nullable>>
          <<if field oneOne or oneMany>>
            <<field camel>>: { connect: <<field camel>> },
          <<endif>>
          <<if field manyMany>>
            <<field camel>>: { set: <<field camel>> },
          <<endif>>
        <<endif>>
        <<if field nullable>>
          <<if field oneOne or oneMany>>
            <<field camel>>: <<field camel>> ? { connect: <<field camel>> } : undefined,
          <<endif>>
          <<if field manyMany>>
            <<field camel>>: <<field camel>> ? { set: <<field camel>> } : undefined,
          <<endif>>
        <<endif>>
      <<endfor>>


      <<for root.referencedIn ref>>
        <<for ref.fields oneOne or oneMany or manyMany field>>
            <<-field backRelation camel>>: <<-field backRelation camel>> ? { set: <<-field backRelation camel>> } : undefined,
        <<endfor>>
      <<endfor>>
    };
  }

  /**
   * Format default select to a prisma select and add ownership constraints
   */
  public getSelectClauseWithOwnershipConstraints(abilities: AppAbility) {
    // Get default select clause
    const select = { ...<<Model constant>>_SELECT };

    if (!abilities) return select;

    // Add ownership constraints
    return {
      ...select,
      <<for Fields manyMany field>>
        <<field camel>>: {
          ...select.<<field camel>>,
          where: !isEmpty(accessibleBy(abilities).<<field.model pascal>>) ?
            accessibleBy(abilities).<<field.model pascal>>
            : undefined
        },
      <<endfor>>
      <<for root.referencedIn ref>>
        <<for ref.fields oneMany or manyMany field>>
          <<-field backRelation camel>>: {
            ...select.<<-field backRelation camel>>,
            where: !isEmpty(accessibleBy(abilities).<<ref pascal>>) ?
              accessibleBy(abilities).<<ref pascal>>
              : undefined
          },
        <<endfor>>
      <<endfor>>
    };
  }

  public removeHiddenProperties({
      <<for Fields hidden field>>
        <<field camel>>,
      <<endfor>>
    ...entity
  }:<<Model pascal>>Dto):<<Model pascal>>ReadDto {
    return {
      ...entity,
    };
  }
}

<<<
function getDefaultForType(f) {
  let out = ""
  if (f.type === "boolean") return "equals";
  else if (f.type === "string") return "equals";
  else if (f.type === "number") return "equals";
  else if (f.type === "datetime") return "equals";
  else if (f.type === "object") return "equals";

  return "UnknownType";
}
>>>

<<<
function getSearchableFields(model) {
  return model
    .fields.list
    .concat(...model.referencedIn)
    .filter((field) => field.searchable && !field.password && !field.hidden);
}
>>>
